<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>NR-09: Anomaly Distribution</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Oxanium:wght@200..800&display=swap');

    body {
      background-color: #0d0d0d;
      color: #00ffcc;
      font-family: 'Oxanium', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 40px;
      margin: 0;
      overflow: hidden;
    }

    /* Loading Screen Styles */
    #loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: #0d0d0d;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      cursor: pointer;
      transition: opacity 1s ease-out;
    }

    #loading-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .loading-animation {
      width: 80px;
      height: 80px;
      border: 3px solid transparent;
      border-top: 3px solid #00ffcc;
      border-radius: 50%;
      animation: spin 1.5s linear infinite;
      margin-bottom: 30px;
      box-shadow: 0 0 20px #00ffcc, 0 0 40px #00ffcc;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .loading-text {
      font-size: 1.8em;
      letter-spacing: 3px;
      text-shadow: 0 0 10px #00ffcc, 0 0 20px #00ffcc;
      animation: pulse 2s ease-in-out infinite;
      margin-top: 20px;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }

    .click-hint {
      position: absolute;
      bottom: 50px;
      font-size: 0.9em;
      opacity: 0.6;
      animation: fadeInOut 3s ease-in-out infinite;
    }

    @keyframes fadeInOut {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.8; }
    }

    /* Main Game Styles */
    #main-content {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      opacity: 0;
      transition: opacity 1s ease-in;
    }

    #main-content.visible {
      opacity: 1;
    }

    h1 {
      font-size: 1.5em;
      margin-bottom: 20px;
      letter-spacing: 2px;
    }

    #turn-indicator {
      margin-bottom: 30px;
      font-size: 1.2em;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(4, 100px);
      gap: 50px;
      margin-top: 70px;
      margin-bottom: 70px;
      justify-content: center;
    }

    .word-button {
      background: transparent;
      border: none;
      padding: 0;
      cursor: pointer;
      width: 80px;
      height: 80px;
      position: relative;
    }

    .word-button img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      transition: opacity 2s ease;
    }

    .fade-out {
      opacity: 0;
    }

    .word-box {
      width: 100%;
      height: 100%;
      background: #111;
      border: 1px solid #00ffcc;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 2s ease;
      position: absolute;
      top: 0;
      left: 0;
      box-shadow: 0 0 10px #00ffcc, 0 0 20px #00ffcc, 0 0 30px #00ffcc;
    }

    .word-box img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .word-box.visible {
      opacity: 1;
    }

    .log-container {
      margin-top: 40px;
      width: 80%;
      border-top: 1px solid #00ffcc;
      padding-top: 20px;
      display: flex;
      justify-content: space-around;
      text-align: center;
    }

    .user-log {
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-width: 100px;
    }

    .user-title {
      font-weight: bold;
      margin-bottom: 10px;
    }

    .log-entry {
      font-size: 1em;
      opacity: 0;
      transition: opacity 1s ease;
      text-shadow: 0 0 5px #00ffcc, 0 0 10px #00ffcc;
    }

    .log-entry.visible {
      opacity: 1;
    }

    .blinking-cursor {
      font-weight: bold;
      margin-left: 5px;
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 50% {
        opacity: 1;
      }
      50.01%, 100% {
        opacity: 0;
      }
    }
  </style>
</head>

<body>

<!-- Loading Screen -->
<div id="loading-screen">
  <div class="loading-animation"></div>
  <div class="loading-text">OVERRIDING CONTAINMENT PROTOCOL</div>
  
</div>

<!-- Main Content -->
<div id="main-content">
  <h1>MF-25<span class="blinking-cursor">_</span></h1>
  <div id="turn-indicator">User 1, choose:</div>

  <div class="grid" id="button-grid"></div>

  <div class="log-container" id="log-container">
    <div class="user-log" id="user-1-log"><div class="user-title">ANOMALY 1</div></div>
    <div class="user-log" id="user-2-log"><div class="user-title">ANOMALY 2</div></div>
    <div class="user-log" id="user-3-log"><div class="user-title">ANOMALY 3</div></div>
    <div class="user-log" id="user-4-log"><div class="user-title">ANOMALY 4</div></div>
  </div>
</div>

<script>
  // Loading screen functionality
  const loadingScreen = document.getElementById('loading-screen');
  const mainContent = document.getElementById('main-content');

  loadingScreen.addEventListener('click', () => {
    document.body.style.overflow = 'auto';
    loadingScreen.classList.add('hidden');
    
    setTimeout(() => {
      mainContent.classList.add('visible');
      initializeGame();
    }, 500);
  });

  // Game variables
  const wordsPool = ['SHNG', 'HSYA', 'VRA', 'KRNA', 'BBTS', 'BYNK', 'RDRA', 'ADBT'];
  const users = ['User 1', 'User 2', 'User 3', 'User 4'];

  const groupA = ['BBTS', 'VRA', 'BYNK', 'RDRA'];
  const groupB = ['KRNA', 'HSYA', 'ADBT', 'SHNG'];

  const forbiddenPairs = [
    ['BBTS', 'SHNG'],
    ['BBTS', 'KRNA']
  ];

  const correlations = {
    'BYNK': 'BHAYANAK',
    'RDRA': 'RAUDRA',
    'BBTS': 'BIBHATSA',
    'KRNA': 'KARUNA',
    'SHNG': 'SHRINGAR',
    'ADBT': 'ADBHUTA',
    'HSYA': 'HASYA',
    'VRA': 'VEERA'
  };

  let assigned = {
    'User 1': [],
    'User 2': [],
    'User 3': [],
    'User 4': []
  };

  let availableWords = [...wordsPool];
  let clickIndex = 0;
  let preGeneratedPairs = [];

  function generateValidDistribution() {
    // Create all possible valid pairs
    const validPairs = [];
    
    for (let i = 0; i < wordsPool.length; i++) {
      for (let j = i + 1; j < wordsPool.length; j++) {
        const word1 = wordsPool[i];
        const word2 = wordsPool[j];
        
        if (isValidPair(word1, word2)) {
          validPairs.push([word1, word2]);
        }
      }
    }
    
    console.log('Valid pairs found:', validPairs); // Debug log
    
    // Try to find a valid distribution
    let attempts = 0;
    const maxAttempts = 1000;
    
    while (attempts < maxAttempts) {
      const shuffledPairs = [...validPairs].sort(() => Math.random() - 0.5);
      const usedWords = new Set();
      const selectedPairs = [];
      
      // Try to select 4 pairs that use all 8 words
      for (const pair of shuffledPairs) {
        if (!usedWords.has(pair[0]) && !usedWords.has(pair[1])) {
          selectedPairs.push(pair);
          usedWords.add(pair[0]);
          usedWords.add(pair[1]);
          
          if (selectedPairs.length === 4) {
            console.log('Selected pairs:', selectedPairs); // Debug log
            
            // Distribute pairs correctly to users
            const shuffledSelectedPairs = selectedPairs.sort(() => Math.random() - 0.5);
            const result = [];
            
            // Each user gets one complete pair
            // User clicks: User1, User2, User3, User4, User1, User2, User3, User4
            // So positions 0,4 go to User1; 1,5 to User2; 2,6 to User3; 3,7 to User4
            
            for (let userIdx = 0; userIdx < 4; userIdx++) {
              const pair = shuffledSelectedPairs[userIdx];
              const firstClickPos = userIdx;       // User's first click: 0,1,2,3
              const secondClickPos = userIdx + 4;  // User's second click: 4,5,6,7
              
              // Randomly decide order within the pair
              if (Math.random() > 0.5) {
                result[firstClickPos] = pair[0];
                result[secondClickPos] = pair[1];
              } else {
                result[firstClickPos] = pair[1];
                result[secondClickPos] = pair[0];
              }
            }
            
            console.log('Final distribution:', result); // Debug log
            console.log('User assignments will be:', {
              'User 1': [result[0], result[4]],
              'User 2': [result[1], result[5]], 
              'User 3': [result[2], result[6]],
              'User 4': [result[3], result[7]]
            });
            return result;
          }
        }
      }
      
      attempts++;
    }
    
    // More careful fallback - ensure it follows all rules
    console.warn('Could not find optimal distribution, using carefully constructed fallback');
    
    // Known valid pairs that follow all rules:
    // Group A: BBTS, VRA, BYNK, RDRA
    // Group B: KRNA, HSYA, ADBT, SHNG  
    // Forbidden: [BBTS,SHNG], [BBTS,KRNA]
    // Valid pairs must be Group A + Group B, avoiding forbidden combinations
    
    // Let's verify each pair is actually valid
    const potentialPairs = [
      ['BBTS', 'ADBT'], // Group A + Group B
      ['VRA', 'KRNA'],  // Group A + Group B
      ['BYNK', 'HSYA'], // Group A + Group B  
      ['RDRA', 'SHNG']  // Group A + Group B
    ];
    
    const knownValidPairs = [];
    
    potentialPairs.forEach(pair => {
      if (isValidPair(pair[0], pair[1])) {
        knownValidPairs.push(pair);
        console.log(`✓ Valid pair: ${pair[0]} (${correlations[pair[0]]}) + ${pair[1]} (${correlations[pair[1]]})`);
      } else {
        console.log(`✗ Invalid pair: ${pair[0]} (${correlations[pair[0]]}) + ${pair[1]} (${correlations[pair[1]]})`);
      }
    });
    
    if (knownValidPairs.length !== 4) {
      console.error('Cannot create 4 valid pairs for fallback!');
      // Try alternative combinations
      const allGroupAPairs = [
        ['BBTS', 'KRNA'], ['BBTS', 'HSYA'], ['BBTS', 'ADBT'], ['BBTS', 'SHNG'],
        ['VRA', 'KRNA'], ['VRA', 'HSYA'], ['VRA', 'ADBT'], ['VRA', 'SHNG'],
        ['BYNK', 'KRNA'], ['BYNK', 'HSYA'], ['BYNK', 'ADBT'], ['BYNK', 'SHNG'],
        ['RDRA', 'KRNA'], ['RDRA', 'HSYA'], ['RDRA', 'ADBT'], ['RDRA', 'SHNG']
      ];
      
      const validAlternatives = allGroupAPairs.filter(pair => isValidPair(pair[0], pair[1]));
      console.log('Valid alternatives found:', validAlternatives);
      
      // Try to pick 4 that use all words
      const usedWords = new Set();
      const finalPairs = [];
      
      for (const pair of validAlternatives) {
        if (!usedWords.has(pair[0]) && !usedWords.has(pair[1])) {
          finalPairs.push(pair);
          usedWords.add(pair[0]);
          usedWords.add(pair[1]);
          
          if (finalPairs.length === 4) break;
        }
      }
      
      if (finalPairs.length === 4) {
        console.log('Using alternative pairs:', finalPairs);
        return finalPairs;
      }
    }
    
    // Create distribution ensuring pairs stay together for each user
    const shuffledKnown = knownValidPairs.sort(() => Math.random() - 0.5);
    const fallbackResult = [];
    
    // Each user gets one complete pair
    // User clicks alternate: User1, User2, User3, User4, User1, User2, User3, User4
    // So positions 0,4 go to User1; 1,5 to User2; 2,6 to User3; 3,7 to User4
    
    // We need to distribute pairs so each user gets their two words in the right positions
    for (let userIdx = 0; userIdx < 4; userIdx++) {
      const pair = shuffledKnown[userIdx];
      const firstClickPos = userIdx;       // User's first click: 0,1,2,3
      const secondClickPos = userIdx + 4;  // User's second click: 4,5,6,7
      
      // Randomly decide order within the pair
      if (Math.random() > 0.5) {
        fallbackResult[firstClickPos] = pair[0];
        fallbackResult[secondClickPos] = pair[1];
      } else {
        fallbackResult[firstClickPos] = pair[1];
        fallbackResult[secondClickPos] = pair[0];
      }
    }
    
    console.log('Fallback distribution:', fallbackResult);
    console.log('Fallback user assignments:', {
      'User 1': [fallbackResult[0], fallbackResult[4]],
      'User 2': [fallbackResult[1], fallbackResult[5]], 
      'User 3': [fallbackResult[2], fallbackResult[6]],
      'User 4': [fallbackResult[3], fallbackResult[7]]
    });
    return fallbackResult;
  }

  function initializeGame() {
    // Pre-generate a valid distribution
    preGeneratedPairs = generateValidDistribution();
    
    const grid = document.getElementById('button-grid');
    const turnIndicator = document.getElementById('turn-indicator');

    // Create 8 buttons
    for (let i = 0; i < 8; i++) {
      const btn = document.createElement('button');
      btn.className = 'word-button';
      btn.disabled = false;

      const img = document.createElement('img');
      img.src = 'folder.png';
      img.alt = 'folder';

      btn.appendChild(img);
      btn.addEventListener('click', () => handleClick(btn, img, i));
      grid.appendChild(btn);
    }
  }

  function handleClick(button, image, buttonIndex) {
    if (clickIndex >= 8 || button.classList.contains('disabled')) return;

    const userIndex = clickIndex % 4;
    const user = users[userIndex];
    
    // Use pre-generated distribution
    const selectedWord = preGeneratedPairs[clickIndex];
    
    if (!selectedWord) {
      console.error('No word available for click', clickIndex);
      return;
    }

    assigned[user].push(selectedWord);
    
    // Debug: Log what each user is getting
    console.log(`Click ${clickIndex}: ${user} gets ${selectedWord} (${correlations[selectedWord]})`);
    console.log(`${user} now has:`, assigned[user].map(w => `${w} (${correlations[w]})`));
    
    // Validate user's pair when they get their second word
    if (assigned[user].length === 2) {
      const word1 = assigned[user][0];
      const word2 = assigned[user][1];
      const isValid = isValidPair(word1, word2);
      console.log(`${user} pair validation: ${word1} + ${word2} = ${isValid ? 'VALID' : 'INVALID'}`);
      if (!isValid) {
        console.error(`INVALID PAIR DETECTED FOR ${user}: ${word1} (${correlations[word1]}) + ${word2} (${correlations[word2]})`);
      }
    }
    
    clickIndex++;

    image.classList.add('fade-out');

    setTimeout(() => {
      image.style.display = 'none';

      const wordBox = document.createElement('div');
      wordBox.className = 'word-box';

      // Add image instead of text
      const rasaImage = document.createElement('img');
      rasaImage.src = `images/${selectedWord}.png`;  // Placeholder path
      rasaImage.alt = correlations[selectedWord] || selectedWord;

      wordBox.appendChild(rasaImage);
      button.appendChild(wordBox);

      // Fade in image
      setTimeout(() => {
        wordBox.classList.add('visible');

        // Log text label below
        const logId = `user-${userIndex + 1}-log`;
        const userLogDiv = document.getElementById(logId);
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        entry.textContent = correlations[selectedWord] || selectedWord;
        userLogDiv.appendChild(entry);

        setTimeout(() => {
          entry.classList.add('visible');
        }, 10);

        const turnIndicator = document.getElementById('turn-indicator');
        if (clickIndex < 8) {
          const nextUser = users[clickIndex % 4];
          turnIndicator.textContent = `${nextUser}, choose:`;
        } else {
          turnIndicator.textContent = "All anomalies distributed";
        }

      }, 1000);
    }, 1000);

    button.classList.add('disabled');
    button.disabled = true;
  }

  function isValidPair(word1, word2) {
    const sameGroup =
      (groupA.includes(word1) && groupA.includes(word2)) ||
      (groupB.includes(word1) && groupB.includes(word2));

    const isForbidden = forbiddenPairs.some(
      pair => pair.includes(word1) && pair.includes(word2)
    );

    return !sameGroup && !isForbidden;
  }
</script>

</body>
</html>